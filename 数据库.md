@[TOC](数据库面试知识整理)

# 事务
## 概念和四大特性

事务是指一组操作，拥有四大特性：原子性、一致性、隔离性、连续性（也称ACID特性）。
可以通过commit提交一个事务，也可以使用rollback回滚。

1. **原子性**（Atomicity）：事务被视为不可分割的最小单元，要么全部commit成功，要么全部失败rollback；
2. **一致性**（Atomicity）：在事务前后保持一致性状态。在一致性状态下所读的所有数据都是一样的。
3. **隔离性**（Isolation）：事务的修改在最终提交之前对其他事务不可见
4. **连续性**（Durability）：一个事务一旦提交，那么所做的修改永远保存

四大特性之间的关系：
- 连续性：用于应对系统崩溃情况
- 在无并发情况下，自动满足了隔离性（只有一个事务），因此需要满足原子性才能保证一致性
- 在并发情况下，需要同时满足隔离性和原子性来保证一致性

## 并发一致性
- 丢失修改：一个事务提交的更新操作被另一个事务的更新操作覆盖
- 读脏数据：一个事务读取了另一个事务还未提交的修改
- 不可重复读：一个事务读取数据之后在操作期间，另一个事务对其进行了访问和修改，此时事务1再读取时，数据与初始的不一致
- 幻影读：也是不可重复读的一种。一个事务在读取某个范围的数据之后并在操作期间，另一个事务对该区间进行了操作，那么事务1再次读取该区间就与初始的不一致

因此需要在事务操作时候进行进行一些隔离操作
## 解决并发一致性问题
### 隔离级别
未提交读：事务的修改对其他事务是可见的
提交读：事务的修改只有提交之后才对其他事务可见
可重复读：保证一个事务多次读取的结果是一样的
可串行化：强制事务串行执行
### 多版本并发控制（Multi-Version Concurrency Control, MVCC）
 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。在MVCC中，事务的修改操作会为事务增加一个版本快照。为了解决不可重复读和脏读问题，MVCC规定只能读取已经提交的快照

# 数据库中的锁
## 锁的分类
- 从数据大小粒度来看：分为行级锁 和 表级锁 （锁一行数据 和 锁一张表数据 的区别）
- 【重要】从处理并发一致性角度来看：
  - 乐观锁：基于数据本身就可以实现，在修改提交前后校对版本号。（多版本并发控制）
  - 悲观锁：在读写之前先加锁 （隔离级别）
     - 排它锁：（Exclusive）X锁，又称写锁。一旦加锁，其他事务不可写入
     - 共享锁  （Shared） S锁，又称读锁。加锁之后，不可以更新只能读取。在此期间其他事务也可以加S锁，但是不能加X锁。
- 意向锁（悲观锁的升级版）：
  - IX和IS锁，表示想要加锁的意向。
  - 为什么有意向锁：可以解决事务在加读写锁之前，需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。
 
## 封锁协议
1. 一级封锁协议：事务修改数据的时候必须加写锁，直到事务结束才能释放锁。--> 丢失修改
2. 二级封锁协议：事务在读取数据的时候必须加读锁，读完立马释放。（在一级封锁协议上建立）--> 读脏数据
3. 三级封锁协议：事务在读取时候必须加读锁，事务结束才能释放。-->不可重复读

4. 二段锁协议：加锁和解锁分为两个阶段进行。事务遵循两段锁协议是保证可串行化调度的充分条件。
可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。
 
## 特别的锁：死锁
死锁的操作分为：避免、检测及解决
### 死锁的避免
### 死锁的检测及解决
# 索引
用于提高查询效率。
可以分为单列索引和多列索引，其中单列索引还可以分为：主键索引、唯一索引、普通索引。
前两者必须是值唯一，且主键无空值，唯一可空值

## 存储引擎
### InnoDB
事务型存储引擎，支持外键、行级锁、支持热备份

### MylSAM
表级锁、支持表压缩、空间数据索引
## 索引实现的数据结构
对于InnoDB有B+树和hashmap
### B+树
B树（二叉查找树）+叶子节点顺序指针访问
对比红黑树的优势：
更短的树高，因此有更少的磁盘寻道次数、因为顺序指针也可以进行磁盘预读
不仅可以查找还可以排序和分组

### Hashmap
精确查找，无法排序分组，也不能区域查找
InnoDB中对于经常查找的索引可以建立hash来加快查询，叫做“自适应哈希查询”

对于MylSAM:有空间数据索引 和全文索引
### 空间数据索引
可以存放地理数据，从各个维度进行索引

### 全文索引
进行关键词索引，对各个关键词建立映射关系
## 复制
分库分表，主从复制，读写分离
读写分离：主服务器写，从服务器读
可以缓解锁的竞争，从服务器可以用MylSAM节约开销

主从复制
这里盗来一张图
主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）
![主从复制](https://img-blog.csdnimg.cn/20200913173032830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmd6aG91MzM=,size_14,color_FFFFFF,t_70#pic_center)

# 关系数据库常见设计范式
[范式详细说明点这里](https://www.zhihu.com/question/24696366)
一范式：关系中每个属性都不可以再分
二范式：在一范式的基础上，消除了非主属性对于码的部分函数依赖
三范式：在2NF的基础之上，消除了非主属性对于码的传递函数依赖

## 数据库结构优化
- 范式优化
- 反范式优化
- 拆分表
## 查询优化
分解大链接查询：将join转为多个小表查询并且用in

- join一旦一张表有修改，其他表都不可以读取
- 多张小表查询可以方便其他需要访问的事务
- 提高效率

切分查询

- 水平切分查询（shading）
 - 连接一致性问题：
  - 使用全局ID
  -  用ID范围进行控制
  - 分布式ID
- 垂直切分查询
