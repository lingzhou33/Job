@[TOC](数据库面试整理)

# 事务
## 概念和四大特性

事务是指一组操作，拥有四大特性：原子性、一致性、隔离性、连续性（也称ACID特性）。
可以通过commit提交一个事务，也可以使用rollback回滚。

1. **原子性**（Atomicity）：事务被视为不可分割的最小单元，要么全部commit成功，要么全部失败rollback；
2. **一致性**（Atomicity）：在事务前后保持一致性状态。在一致性状态下所读的所有数据都是一样的。
3. **隔离性**（Isolation）：事务的修改在最终提交之前对其他事务不可见
4. **连续性**（Durability）：一个事务一旦提交，那么所做的修改永远保存

四大特性之间的关系：
- 连续性：用于应对系统崩溃情况
- 在无并发情况下，自动满足了隔离性（只有一个事务），因此需要满足原子性才能保证一致性
- 在并发情况下，需要同时满足隔离性和原子性来保证一致性

## 并发一致性（数据库隔离级别）
- 丢失修改：一个事务提交的更新操作被另一个事务的更新操作覆盖
- 读脏数据：一个事务读取了另一个事务还未提交的修改
- 不可重复读：一个事务读取数据之后在操作期间，另一个事务对其进行了访问和修改，此时事务1再读取时，数据与初始的不一致
- 幻影读：也是不可重复读的一种。一个事务在读取某个范围的数据之后并在操作期间，另一个事务对该区间进行了操作，那么事务1再次读取该区间就与初始的不一致

因此需要在事务操作时候进行加锁操作

# 数据库中的锁
## 锁的分类
- 从数据大小粒度来看：分为行级锁 和 表级锁 （锁一行数据 和 锁一张表数据 的区别）
- 【重要】从处理并发一致性角度来看：
  - 乐观锁：基于数据本身就可以实现，在修改提交前后校对版本号
  - 悲观锁：在读写之前先加锁
     - 排它锁：（Exclusive）X锁，又称写锁。一旦加锁，其他事务不可写入
     - 共享锁  （Shared） S锁，又称读锁。加锁之后，不可以更新只能读取。在此期间其他事务也可以加S锁，但是不能加X锁。
- 意向锁（悲观锁的升级版）：
  - IX和IS锁，表示想要加锁的意向。
  - 为什么有意向锁：可以解决事务在加读写锁之前，需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。
 
## 封锁协议
 
## 特别的锁：死锁

